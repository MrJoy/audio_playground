#!/usr/bin/env ruby

###############################################################################
# Early Initialization/Helpers
###############################################################################
lib = File.expand_path("../../lib", __FILE__)
$LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)
require "sparkle_motion"
SparkleMotion.init!("sm-mark-lights")
SparkleMotion.use_hue!(api: true)
LOGGER = SparkleMotion.logger
extend SparkleMotion::Hue::HTTP

###############################################################################
# Main Logic
###############################################################################
# TODO: Use Novation Launchpad to be able to toggle lights.
BASE_LIGHT_OPTIONS = { "on" => true }

# TODO: Speed this up by setting on/hue via group message per bridge...
requests_by_bridge = {}
CONFIG["light_groups"].keys.each do |group_name|
  config = SparkleMotion::LightConfig.new(config: CONFIG, group: group_name)

  config.bridges.each do |bridge_name, bridge|
    requests    = []
    light_ids   = config.lights[bridge_name].map(&:last)
    num_lights  = light_ids.length.to_f
    light_ids.each_with_index do |light_id, index|
      light_payload = { "on" => true,
                        "hue" => bridge["debug_hue"],
                        "bri" => 0 } #(232 * (index / num_lights)).round + 23 }
      requests << light_update(bridge, light_id, payload: light_payload,
                                                 transition: 50)
    end
    requests_by_bridge[bridge_name] ||= []
    requests_by_bridge[bridge_name] += requests
  end
end

threads = requests_by_bridge.values.map do |requests|
  Thread.start do
    perform_with_retries(requests, options: { max_connects: 1 }) do |_easy, request|
      LOGGER.info { "Updated light on #{request.bridge['name']}: #{request.url}" }
      sleep 0.075
    end
  end
end

threads.map(&:join)
