#!/usr/bin/env ruby
require "rubygems"
require "bundler/setup"
Bundler.setup
require "set"
require "thread"
require "coreaudio"
require "numru/fftw3"

WINDOW      = 4096
FREQ_RANGE  = [500, 3_000]

Thread.abort_on_exception = true

# Represents parameters of a simple band-pass filter, and computes which buckets of an FFT are
# relevant.
class BandPassFilter
  attr_reader :frequency_range, :bin_start, :bin_end, :bin_count
  def initialize(freq_range, sample_rate, window, &callback)
    @sample_rate          = sample_rate
    @window               = window
    @callback             = callback
    self.frequency_range  = freq_range
  end

  def frequency_range=(val)
    return if @frequency_range == val
    @frequency_range = val.dup
    compute_bins!
  end

  def apply!(fft)
    # Example code demonstrating a pitch-shift, from here:
    # https://github.com/nagachika/ruby-coreaudio/blob/master/examples/fft_shift_pitch.rb
    #   shift = 12
    #   f[ch, (shift + 1)...half] = f[ch, 1...(half - shift)]
    #   f[ch, 1..shift] = 0
    #   f[ch, (half + 1)...(w.shape[1] - shift)] = f[ch, (half + shift + 1)..-1]
    #   f[ch, -shift..-1] = 0

    # Low-pass portion of filter:
    apply_low_pass!(fft)

    # High-pass portion of filter:
    apply_high_pass!(fft)
  end

protected

  def apply_low_pass!(fft)
    return unless bin_start > 1
    fft[1..(bin_start - 1)]    = 0
    fft[-(bin_start - 1)..-1]  = 0
  end

  def apply_high_pass!(fft)
    half = fft.length / 2
    return unless bin_end <= half
    fft[(bin_end + 1)...half]  = 0
    fft[(half + 1)...-(bin_end + 1)] = 0
  end

  # def bin_freq(idx); ((idx - 1) * @sample_rate) / @window; end
  def freq_bin(hz); ((hz * @window) / @sample_rate).round; end

  def compute_bins!
    @bin_start = (freq_bin(@frequency_range.first) / 2) + 1
    @bin_end   = (freq_bin(@frequency_range.last) / 2) + 1
    @bin_count = bin_end - bin_start + 1
    @callback.call(@bin_start, @bin_end, @bin_count) if @callback
  end
end

def configure_output_device(rate)
  available_rates = CoreAudio.default_output_device.available_sample_rate.flatten.uniq
  rate = rate.to_f
  unless rate && available_rates.member?(rate)
    fail "Can't set default output device to #{rate}hz!"
  end

  CoreAudio.default_output_device(nominal_rate: rate)
end

# Example of how to save data:
#   wav = CoreAudio::AudioFile.new("sample.wav", :write, format:  :wav,
#                                                        rate:     dev.nominal_rate,
#                                                        channels: dev.input_stream.channels)
#   wav.write(w)
#   wav.close

DEVICE_PATTERN = /\A--input-device=/
FILE_PATTERN = /\A--input-file=/
input_name = ARGV.find { |arg| arg =~ DEVICE_PATTERN } ||
             ARGV.find { |arg| arg =~ FILE_PATTERN }
fail "Must specify --input-device, or --input-file parameter!" unless input_name
if input_name =~ DEVICE_PATTERN
  input_name    = input_name.sub(DEVICE_PATTERN, "")
  input_device  = CoreAudio.devices.find { |dev| dev.name =~ /#{input_name}/ }
  fail "No such device ID!" unless input_device

  input_name    = input_device.name
  sample_rate   = input_device.actual_rate
  inbuf         = input_device.input_buffer(WINDOW)
  inbuf.start
elsif input_name =~ FILE_PATTERN
  input_name = input_name.sub(FILE_PATTERN, "")
  input_file = CoreAudio::AudioFile.new(input_name, :read)

  sample_rate = input_file.rate # Do we want `inner_rate` instead?
  inbuf       = input_file
end

# TODO: Coerce devices to nominal rate?
queue         = Queue.new
report        = { name:    input_name,
                  dc0:     [],
                  min:     [],
                  max:     [],
                  current: [],
                  count:   0 }
filter        = BandPassFilter
                .new(FREQ_RANGE, sample_rate, WINDOW) do |bin_start, bin_end, bin_count|
                  puts "#{input_name}: #{bin_count} bins, from #{bin_start} to #{bin_end}."
                  report[:count]  = 0
                  report[:min]    = []
                  report[:max]    = []
                end

puts "#{input_name}: Sample rate is #{sample_rate}hz."

play_audio = ARGV.find { |arg| arg =~ /\A--playback=/ }
if play_audio
  play_audio        = play_audio.sub(/\A--playback=\s*/, "")
  playback_channels = Set.new(play_audio.split(/\s*,\s*/).map(&:to_i))
  configure_output_device(sample_rate)
  output_device     = CoreAudio.default_output_device
  output_rate       = output_device.actual_rate
  puts "#{output_device.name}: Sample rate is #{output_rate}hz."
  fail "Input device and output device have different sample rates!" if output_rate != sample_rate
  outbuf = output_device.output_buffer(WINDOW)
  outbuf.start
end

# TODO: Look into this to allow routing AudioHijack output into processor? http://www.ambrosiasw.com/utilities/wta/
# TODO: ... or maybe this? http://www.jackosx.com/
# http://www.abstractnew.com/2014/04/the-fast-fourier-transform-fft-without.html

filter_thread = Thread.start do
  loop do
    w = queue.pop
    break unless w
    report[:count] += 1

    # TODO: We get back a 2D matrix.  It's... *supposed* to be per-channel?  Why aren't we seeing
    # TODO: independent results?
    output = []
    (0..(w.shape[0] - 1)).each do |ch|
      f = NumRu::FFTW3.fft(w[ch, 0..-1], -1, 0) / w.shape[1]

      # Re-assigning this to pick up any changes.
      filter.frequency_range = FREQ_RANGE
      filter.apply!(f)

      # Because of NArray, the `map` leaves magnitude of each `Complex` in the
      # real component of a new Complex.
      # Magnitude here gives us power**0.5, I think?
      # amplitudes            = f[ch, 1..-1].map(&:magnitude)
      # avg_amplitude         = amplitudes.sum.real / amplitudes.size
      amplitudes            = f[filter.bin_start..filter.bin_end].map(&:magnitude)
      avg_amplitude         = amplitudes.sum.real / filter.bin_count
      report[:dc0][ch]      = f[0]
      report[:min][ch]    ||= Float::INFINITY
      report[:min][ch]      = avg_amplitude if avg_amplitude < report[:min][ch]
      report[:max][ch]    ||= 0.0
      report[:max][ch]      = avg_amplitude if avg_amplitude > report[:max][ch]
      report[:current][ch]  = avg_amplitude

      output << NumRu::FFTW3.fft(f[0..-1], 1, 0) if outbuf && playback_channels.include?(ch)
    end

    next unless output.length > 0

    # TODO: Sanity-check that the length is sane for the output device...
    output[0..1].each_with_index do |data, idx|
      w[idx, 0..-1] = data
    end

    outbuf << w[(output.length > 1) ? 0..1 : 0, 0..-1]
  end
end

input_thread = Thread.start do
  loop do
    data = inbuf.read(WINDOW)
    queue.push(data)
    break unless data
  end
end

reporting_thread = Thread.start do
  last_count = 0
  loop do
    next if report[:count] == last_count
    last_count = report[:count]
    title = "%s[%05d, %05d]:" % [report[:name],
                                 report[:count],
                                 input_device ? inbuf.dropped_frame : 0]
    puts "%30s %10.1f <= %10.1f <= %10.1f (dc0=%s)" % [title,
                                                       report[:min][0],
                                                       report[:current][0],
                                                       report[:max][0],
                                                       report[:dc0][0]]
    if report[:min].length > 1
      (1..(report[:min].length - 1)).each do |ch|
        puts "%30s %10.1f <= %10.1f <= %10.1f (dc0=%s)" % ["",
                                                           report[:min][ch],
                                                           report[:current][ch],
                                                           report[:max][ch],
                                                           report[:dc0][ch]]
      end
    end
    sleep 1.0
  end
end

if input_device
  $stdout.puts "Commands:"
  $stdout.puts "  >X      Filter for frequencies above X, defaults to #{FREQ_RANGE.first}."
  $stdout.puts "  <X      Filter for frequencies below X, defaults to #{FREQ_RANGE.last}."
  $stdout.puts "  quit    Exit the program."
  $stdout.flush
  loop do
    line = $stdin.gets.strip
    break if line =~ /\Aquit\z/

    FREQ_RANGE[0] = Regexp.last_match(1).to_i if line =~ />\s*(\d+)/
    FREQ_RANGE[1] = Regexp.last_match(1).to_i if line =~ /<\s*(\d+)/
  end
  input_thread.kill.join
  inbuf.stop
  queue.push(nil)
  filter_thread.kill.join
else
  input_thread.join
  filter_thread.join
end

reporting_thread.kill.join
outbuf.stop if outbuf
