#!/usr/bin/env ruby
lib = File.expand_path("../../lib", __FILE__)
$LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)
require "sparkle_motion"
SparkleMotion.init!
SparkleMotion.use_cli!
SparkleMotion.use_audio!
LOGGER = SparkleMotion.logger
require "set"

WINDOW = 4096

Thread.abort_on_exception = true

# Example of how to save data:
#   wav = CoreAudio::AudioFile.new("sample.wav", :write, format:  :wav,
#                                                        rate:     dev.nominal_rate,
#                                                        channels: dev.input_stream.channels)
#   wav.write(w)
#   wav.close

ALLOWED_MODES = Set.new(%i(interactive batch))
parser = SparkleMotion::CLI::ArgumentParser
         .new(defaults: { low:             true,
                          high:            true,
                          in_class:        nil,
                          in_source:       nil,
                          mode:            :batch,
                          play:            nil,
                          frequency_range: [500, 3_000] },
              kinds:    { input: %i(input_device input_file) },
              required: %i(input),
              allowed:  %i(skip_low skip_high freq_start freq_end input_device
                           input_file play mode))
options, leftovers = parser
                     .parse!(ARGV) do |name, value, result|
                       case name
                       when :skip_low   then result[:low] = false
                       when :skip_high  then result[:high] = false
                       when :freq_start then result[:frequency_range][0] = value.to_i
                       when :freq_end   then result[:frequency_range][1] = value.to_i
                       when :input_device
                         parser.incompatible_args!("input") if result[:in_class]
                         result[:in_class]  = SparkleMotion::Audio::DeviceInputStream
                         result[:in_source] = value
                       when :input_file then
                         parser.incompatible_args!("input") if result[:in_class]
                         result[:in_class]  = SparkleMotion::Audio::FileInputStream
                         result[:in_source] = value
                       when :play then
                         channels = value ? Set.new(value.split(/\s*,\s*/).map(&:to_i)) : [0, 1]
                         result[:play] = channels
                       when :mode then
                         value = value.to_sym
                         result[:mode] = value
                         parser.invalid_value!(name, value) unless ALLOWED_MODES.include?(value)
                       end
                     end
if leftovers.length > 0
  LOGGER.error { "Unexpected arguments: #{leftovers.inspect}" }
  exit 1
end

in_stream = options[:in_class].new(options[:in_source], WINDOW)
puts "#{in_stream.name}: Sample rate is #{in_stream.sample_rate}hz."

reporter = SparkleMotion::Audio::StreamReporter.new(in_stream.name, 1.0, LOGGER)

use_low   = options[:low]
use_high  = options[:high]
range     = options[:frequency_range]
filter    = SparkleMotion::Audio::BandPassFilter
            .new(range, in_stream.sample_rate, WINDOW, use_low, use_high) do |ss, ee, cc|
              puts "#{in_stream.name}: #{cc} bins, from #{ss} to #{ee}."
              reporter.reset!
            end

if options[:play]
  out_stream = SparkleMotion::Audio::DeviceOutputStream.new(in_stream.sample_rate, WINDOW)
  puts "#{out_stream.name}: Sample rate is #{out_stream.sample_rate}hz."
end

# TODO: Look into this to allow routing AudioHijack output into processor? http://www.ambrosiasw.com/utilities/wta/
# TODO: ... or maybe this? http://www.jackosx.com/
# http://www.abstractnew.com/2014/04/the-fast-fourier-transform-fft-without.html

processor = SparkleMotion::Audio::StreamFilter.new(in_stream, filter, LOGGER) do |snapshot, dc|
  computed = snapshot
             .map do |data|
               # Because of NArray, the `map` leaves magnitude of each `Complex` in the
               # real component of a new Complex.
               # Magnitude here gives us power**0.5, I think?
               # amplitudes            = f[ch, 1..-1].map(&:magnitude).real
               # avg_amplitude         = amplitudes.sum / amplitudes.size
               amplitudes    = data[filter.bin_start..filter.bin_end].map(&:magnitude).real
               avg_amplitude = amplitudes.sum / filter.bin_count
               { dc0: data[0], mean: avg_amplitude }
             end

  reporter.record(dropped_frames: dc,
                  data:           computed)
end

out_stream.start if out_stream
in_stream.start
processor.send_to(options[:play], out_stream) if out_stream
processor.start
reporter.start unless in_stream.finite?

case options[:mode]
when :interactive
  $stdout.puts "Commands:"
  $stdout.puts "  >X      Filter for frequencies above X, defaults to #{FREQ_RANGE.first}."
  $stdout.puts "  <X      Filter for frequencies below X, defaults to #{FREQ_RANGE.last}."
  $stdout.puts "  quit    Exit the program."
  $stdout.flush
  loop do
    line = $stdin.gets.strip
    break if line =~ /\Aquit\z/

    FREQ_RANGE[0] = Regexp.last_match(1).to_i if line =~ />\s*(\d+)/
    FREQ_RANGE[1] = Regexp.last_match(1).to_i if line =~ /<\s*(\d+)/
  end
when :batch
  loop { sleep 0.1 } unless in_stream.finite?
end

in_stream.stop
processor.await
if in_stream.finite?
  reporter.print_report
else
  reporter.stop
end
out_stream.stop if out_stream
