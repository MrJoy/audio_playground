#!/usr/bin/env ruby
require "rubygems"
require "bundler/setup"
Bundler.setup
require "thread"
require "coreaudio"
require "numru/fftw3"

# For 300Hz..3kHz:
#    512 == bins 4..36 (33)
#   1024 == bins 8..71 (64)
#   2048 == bins 15..140 (126)
#   4096 == bins 29..280 (252)
WINDOW      = 4096
FREQ_RANGE  = [300, 3_000]

Thread.abort_on_exception = true

# Represents parameters of a simple band-pass filter, and computes which buckets of an FFT are
# relevant.
class BandPassFilter
  attr_reader :frequency_range, :bin_start, :bin_end, :bin_count
  def initialize(freq_range, sample_rate, window, &callback)
    @sample_rate          = sample_rate
    @window               = window
    @callback             = callback
    self.frequency_range  = freq_range
  end

  def frequency_range=(val)
    return if @frequency_range == val
    @frequency_range = val.dup
    compute_bins!
  end

  def apply!(fft)
    (0..(fft.shape[0] - 1)).each do |ch|
      # Example code demonstrating a pitch-shift:
      # shift = 12
      # f[ch, (shift + 1)...half] = f[ch, 1...(half - shift)]
      # f[ch, 1..shift] = 0
      # f[ch, (half + 1)...(w.shape[1] - shift)] = f[ch, (half + shift + 1)..-1]
      # f[ch, -shift..-1] = 0

      # Low-pass portion of filter:
      apply_low_pass!(fft, ch)

      # High-pass portion of filter:
      apply_high_pass!(fft, ch)
    end
  end

protected

  def apply_low_pass!(fft, ch)
    return unless bin_start > 1
    fft[ch, 1..(bin_start - 1)]    = 0
    fft[ch, -(bin_start - 1)..-1]  = 0
  end

  def apply_high_pass!(fft, ch)
    half = fft.shape[1] / 2
    return unless bin_end < half
    fft[ch, (bin_end + 1)...half]  = 0
    fft[ch, half...-(bin_end + 1)] = 0
  end

  # def bin_freq(idx); ((idx - 1) * @sample_rate) / @window; end
  def freq_bin(hz); ((hz * @window) / @sample_rate).round; end

  def compute_bins!
    @bin_start = (freq_bin(@frequency_range.first) / 2) + 1
    @bin_end   = (freq_bin(@frequency_range.last) / 2) + 1
    @bin_count = bin_end - bin_start + 1
    @callback.call(@bin_start, @bin_end, @bin_count) if @callback
  end
end

input_name = ARGV.find { |arg| arg =~ /\A--input=/ }
fail "Must specify --input parameter!" unless input_name
input_name = input_name.sub(/\A--input=/, "")

input_device  = CoreAudio.devices.find { |dev| dev.name =~ /#{input_name}/ }
fail "No such device ID!" unless input_device

# TODO: Coerce device to 44.1kHz?
queue         = Queue.new
inbuf         = input_device.input_buffer(WINDOW)
sample_rate   = input_device.actual_rate
report        = { name:    input_device.name,
                  dc0:     [nil],
                  min:     [Float::INFINITY],
                  max:     [0.0],
                  current: [0.0],
                  count:   0 }
filter        = BandPassFilter
                .new(FREQ_RANGE, sample_rate, WINDOW) do |bin_start, bin_end, bin_count|
                  puts "#{input_device.name}: #{bin_count} bins, from #{bin_start} to #{bin_end}."
                  report[:min] = [Float::INFINITY] * report[:min].length
                  report[:max] = [0.0] * report[:max].length
                end

puts "#{input_device.name}: Sample rate is #{sample_rate}hz."\
  " Nominal rate is #{input_device.nominal_rate}."

play_audio = !!ARGV.find { |arg| arg == "--playback" }
if play_audio
  output_device = CoreAudio.default_output_device
  output_rate   = output_device.actual_rate
  puts "#{output_device.name}: Sample rate is #{output_rate}hz."\
    " Nominal rate is #{output_device.nominal_rate}."
  fail "Input device and output device have different sample rates!" if output_rate != sample_rate
  outbuf = output_device.output_buffer(WINDOW)
  outbuf.start
end

# wav = CoreAudio::AudioFile.new("sample.wav", :read)
# m4a = CoreAudio::AudioFile.new("sample.m4a", :write, :format => :m4a,
#                                :rate => wav.rate,
#                                :channels => wav.channels)
# loop do
#   buf = wav.read(1024)
#   break if buf.nil?
#   m4a.write(buf)
# end
# wav.close
# m4a.close

# TODO: Look into this to allow routing AudioHijack output into processor? http://www.ambrosiasw.com/utilities/wta/
# http://www.abstractnew.com/2014/04/the-fast-fourier-transform-fft-without.html

filter_thread = Thread.start do
  loop do
    w = queue.pop
    break unless w
    report[:count] += 1

    # TODO: We get back a 2D matrix.  Is that about stereo channels, or something else?
    f = NumRu::FFTW3.fft(w, -1, 0, 1) / (w.shape[0] * w.shape[1])

    # Re-assigning this to pick up any changes.
    filter.frequency_range = FREQ_RANGE
    filter.apply!(f)

    (0..(f.shape[0] - 1)).each do |ch|
      # Because of NArray, the `map` leaves magnitude of each `Complex` in the
      # real component of a new Complex.
      # Magnitude here gives us power**0.5, I think?
      amplitudes            = f[ch, filter.bin_start..filter.bin_end].map(&:magnitude)
      avg_amplitude         = amplitudes.sum.real / filter.bin_count
      report[:dc0][ch]      = f[ch, 0]
      report[:min][ch]    ||= Float::INFINITY
      report[:min][ch]      = avg_amplitude if avg_amplitude < report[:min][ch]
      report[:max][ch]    ||= 0.0
      report[:max][ch]      = avg_amplitude if avg_amplitude > report[:max][ch]
      report[:current][ch]  = avg_amplitude
    end

    outbuf << NumRu::FFTW3.fft(f[0..1, 0..-1], 1, 0, 1) if outbuf
  end
end

input_thread = Thread.start do
  loop do
    queue.push(inbuf.read(WINDOW))
  end
end

reporting_thread = Thread.start do
  last_count = 0
  loop do
    sleep 1.0
    next unless report[:count] > last_count
    last_count = report[:count]
    title = "%s[%05d]:" % [report[:name], report[:count]]
    puts "%30s %10.1f <= %10.1f <= %10.1f (dc0=%s)" % [title,
                                                       report[:min][0],
                                                       report[:current][0],
                                                       report[:max][0],
                                                       report[:dc0][0]]
    next unless report[:min].length > 1
    (1..(report[:min].length - 1)).each do |ch|
      puts "%30s %10.1f <= %10.1f <= %10.1f (dc0=%s)" % ["",
                                                         report[:min][ch],
                                                         report[:current][ch],
                                                         report[:max][ch],
                                                         report[:dc0][ch]]
    end
    puts
  end
end

$stdout.puts "Commands:"
$stdout.puts "  >X      Filter for frequencies above X, defaults to #{FREQ_RANGE.first}."
$stdout.puts "  <X      Filter for frequencies below X, defaults to #{FREQ_RANGE.last}."
$stdout.puts "  quit    Exit the program."
$stdout.flush

inbuf.start

loop do
  line = $stdin.gets.strip
  break if line =~ /\Aquit\z/

  FREQ_RANGE[0] = Regexp.last_match(1).to_i if line =~ />\s*(\d+)/
  FREQ_RANGE[1] = Regexp.last_match(1).to_i if line =~ /<\s*(\d+)/
end

input_thread.kill.join
inbuf.stop
queue.push(nil)
filter_thread.kill.join
reporting_thread.kill.join
outbuf.stop if outbuf

puts "#{inbuf.dropped_frame} frames dropped at input buffer."
