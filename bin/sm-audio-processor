#!/usr/bin/env ruby
lib = File.expand_path("../../lib", __FILE__)
$LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)
require "sparkle_motion"
SparkleMotion.init!
SparkleMotion.use_audio!
LOGGER = SparkleMotion.logger
require "set"
require "numru/fftw3"

WINDOW      = 4096
FREQ_RANGE  = [500, 3_000]

Thread.abort_on_exception = true

# Example of how to save data:
#   wav = CoreAudio::AudioFile.new("sample.wav", :write, format:  :wav,
#                                                        rate:     dev.nominal_rate,
#                                                        channels: dev.input_stream.channels)
#   wav.write(w)
#   wav.close

enable_low  = !ARGV.find { |arg| arg =~ /\A--skip-low\z/ }
enable_high = !ARGV.find { |arg| arg =~ /\A--skip-high\z/ }
freq_min  = ARGV.find { |arg| arg =~ /\A--freq-min=/ }
freq_max  = ARGV.find { |arg| arg =~ /\A--freq-max=/ }

freq_min = freq_min.sub(/\A--freq-min=/, "").strip.to_i if freq_min
freq_max = freq_max.sub(/\A--freq-max=/, "").strip.to_i if freq_max

FREQ_RANGE[0] = freq_min if freq_min
FREQ_RANGE[1] = freq_max if freq_max

DEVICE_PATTERN = /\A--input-device=/
FILE_PATTERN = /\A--input-file=/
input_name = ARGV.find { |arg| arg =~ DEVICE_PATTERN } ||
             ARGV.find { |arg| arg =~ FILE_PATTERN }
fail "Must specify --input-device, or --input-file parameter!" unless input_name
if input_name =~ DEVICE_PATTERN
  input_name = input_name.sub(DEVICE_PATTERN, "")
  in_stream = SparkleMotion::Audio::DeviceInputStream.new(input_name, WINDOW)
elsif input_name =~ FILE_PATTERN
  input_name = input_name.sub(FILE_PATTERN, "")
  in_stream = SparkleMotion::Audio::FileInputStream.new(input_name, WINDOW)
end

# TODO: Coerce devices to nominal rate?
report = { dc0:     [],
           min:     [],
           max:     [],
           current: [],
           count:   0,
           done:    false }
filter = SparkleMotion::Audio::BandPassFilter
         .new(FREQ_RANGE, in_stream.sample_rate, WINDOW, enable_low, enable_high) do |ss, ee, cc|
           puts "#{in_stream.name}: #{cc} bins, from #{ss} to #{ee}."
           report[:count]  = 0
           report[:min]    = []
           report[:max]    = []
         end

puts "#{in_stream.name}: Sample rate is #{in_stream.sample_rate}hz."

play_audio = ARGV.find { |arg| arg =~ /\A--playback=/ }
if play_audio
  play_audio        = play_audio.sub(/\A--playback=\s*/, "")
  playback_channels = Set.new(play_audio.split(/\s*,\s*/).map(&:to_i))
  out_stream = SparkleMotion::Audio::DeviceOutputStream.new(in_stream.sample_rate, WINDOW)
  puts "#{out_stream.name}: Sample rate is #{out_stream.sample_rate}hz."
end

interactive = ARGV.find { |arg| arg =~ /\A--interactive\z/ }
batch       = ARGV.find { |arg| arg =~ /\A--batch\z/ }
if (interactive && batch) || (!interactive && !batch)
  fail "Must specify one of --batch or --interactive"
end
interactive = false if batch

# TODO: Look into this to allow routing AudioHijack output into processor? http://www.ambrosiasw.com/utilities/wta/
# TODO: ... or maybe this? http://www.jackosx.com/
# http://www.abstractnew.com/2014/04/the-fast-fourier-transform-fft-without.html

filter_thread = Thread.new do
  Thread.stop

  loop do
    w = in_stream.pop
    break unless w && w.shape[1] == WINDOW

    # Re-assigning this to pick up any changes.
    filter.frequency_range = FREQ_RANGE

    # TODO: We get back a 2D matrix.  It's... *supposed* to be per-channel?  Why aren't we seeing
    # TODO: independent results?
    output = []
    (0..(w.shape[0] - 1)).each do |ch|
      f = NumRu::FFTW3.fft(w[ch, 0..-1], -1, 0) / w.shape[1]

      # Now, apply our filter...
      filter.apply!(f)

      # Because of NArray, the `map` leaves magnitude of each `Complex` in the
      # real component of a new Complex.
      # Magnitude here gives us power**0.5, I think?
      # amplitudes            = f[ch, 1..-1].map(&:magnitude).real
      # avg_amplitude         = amplitudes.sum / amplitudes.size
      amplitudes            = f[filter.bin_start..filter.bin_end].map(&:magnitude).real
      avg_amplitude         = amplitudes.sum / filter.bin_count
      report[:dc0][ch]      = f[0]
      report[:min][ch]    ||= Float::INFINITY
      report[:min][ch]      = avg_amplitude if avg_amplitude < report[:min][ch]
      report[:max][ch]    ||= 0.0
      report[:max][ch]      = avg_amplitude if avg_amplitude > report[:max][ch]
      report[:current][ch]  = avg_amplitude

      output << NumRu::FFTW3.fft(f[0..-1], 1, 0) if out_stream && playback_channels.include?(ch)
    end

    report[:count] += 1
    next unless output.length > 0

    # TODO: Sanity-check that the length is sane for the output device...
    output[0..1].each_with_index do |data, idx|
      w[idx, 0..-1] = data
    end

    out_stream.write(w[(output.length > 1) ? 0..1 : 0, 0..-1])
  end
end

REPORT_FORMAT = "%30s %10.1f <= %10.1f <= %10.1f (dc0=%s)"
def report_channel(title, report, channel)
  puts REPORT_FORMAT % [title,
                        report[:min][channel],
                        report[:current][channel],
                        report[:max][channel],
                        report[:dc0][channel]]
end

def report(in_stream, report)
  title = "%s[%05d, %05d]:" % [in_stream.name, report[:count], in_stream.dropped_frames]
  report_channel(title, report, 0)

  channels = report[:min].length
  return unless channels > 1
  (1..(channels - 1)).each do |ch|
    report_channel("", report, ch)
  end
end

unless in_stream.finite?
  reporting_thread = Thread.new do
    Thread.stop
    last_count = 0
    loop do
      new_count = report[:count]
      next if report[:count] == last_count
      last_count = new_count

      report(in_stream, report)

      sleep 1.0
    end
  end
end

out_stream.start if out_stream
in_stream.start
filter_thread.run
reporting_thread.run if reporting_thread

if interactive
  $stdout.puts "Commands:"
  $stdout.puts "  >X      Filter for frequencies above X, defaults to #{FREQ_RANGE.first}."
  $stdout.puts "  <X      Filter for frequencies below X, defaults to #{FREQ_RANGE.last}."
  $stdout.puts "  quit    Exit the program."
  $stdout.flush
  loop do
    line = $stdin.gets.strip
    break if line =~ /\Aquit\z/

    FREQ_RANGE[0] = Regexp.last_match(1).to_i if line =~ />\s*(\d+)/
    FREQ_RANGE[1] = Regexp.last_match(1).to_i if line =~ /<\s*(\d+)/
  end
end

in_stream.stop
filter_thread.join
if reporting_thread
  reporting_thread.join
else
  report(in_stream, report)
end
out_stream.stop if out_stream
